# =============================================================================
# Install HashiCorp Vault
# - pre: NetworkPolicies
# - install: Official Helm chart (hashicorp/vault)
# - post: Ingress + CronJob for auto-unseal
# =============================================================================
# Fault tolerance: uses temp file to resume from interrupted init
# - If init temp file exists: resume from interrupted init
# - If no temp file and initialized: use main credentials file
#
# Simplified credential flow:
# - Keys are ALWAYS distributed to all managers BEFORE being used for operations
# - set_fact vault_unseal_keys / vault_root_token is ALWAYS from the main file on disk
# =============================================================================

---
- name: Install Vault via Helm
  hosts: managers
  become: true
  gather_facts: false

  tasks:
    - name: "[vault-install-pre-check] Validate target"
      include_tasks: tasks/tasks-pre-check.yaml
      vars:
        label_name: "vault-install-pre-check"

    # =========================================================================
    # STEP 1: INSTALL PRE (NetworkPolicies)
    # =========================================================================

    - name: "[vault-pre] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "vault-pre"
        chart_name: "pre"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/vault/pre/"
        chart_remote_dest: "{{ remote_charts_dir }}/vault/pre"

    - name: "[vault-pre] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/vault/pre/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ vault_namespace }}
          traefik:
            namespace: {{ traefik_namespace }}
          externalSecrets:
            namespace: {{ external_secrets_namespace }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-pre] Install via Helm"
      command: >
        helm upgrade --install vault-pre {{ remote_charts_dir }}/vault/pre
        --namespace {{ vault_namespace }}
        --create-namespace
        --values {{ remote_charts_dir }}/vault/pre/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ vault_config_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 2: INSTALL VAULT (Local Helm Chart)
    # =========================================================================

    - name: "[vault] Copy chart to server"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "vault"
        chart_name: "install"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/vault/install/"
        chart_remote_dest: "{{ remote_charts_dir }}/vault/install"

    - name: "[vault] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/vault/install/values-override.yaml"
        mode: "0644"
        content: |
          global:
            enabled: true

          server:
            enabled: true
            image:
              repository: hashicorp/vault
              tag: {{ vault_image_tag }}

            standalone:
              enabled: true
              config: |
                ui = true
                listener "tcp" {
                  tls_disable = 1
                  address = "[::]:8200"
                  cluster_address = "[::]:8201"
                }
                storage "raft" {
                  path = "/vault/data"
                }

            dataStorage:
              enabled: true
              size: {{ vault_storage_size }}
              storageClass: {{ vault_storage_class }}

            resources: {}
            nodeSelector: {}
            affinity: ""

          ui:
            enabled: true
            serviceType: ClusterIP

          injector:
            enabled: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Install via Helm"
      command: >
        helm upgrade --install vault {{ remote_charts_dir }}/vault/install
        --namespace {{ vault_namespace }}
        --values {{ remote_charts_dir }}/vault/install/values.yaml
        --values {{ remote_charts_dir }}/vault/install/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ vault_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 3: WAIT FOR VAULT POD
    # =========================================================================

    - name: "[vault] Wait for pod to be Running"
      command: >
        kubectl wait --for=jsonpath='{.status.phase}'=Running
        pod/vault-0 -n {{ vault_namespace }}
        --timeout={{ vault_rollout_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 4: CHECK IF VAULT IS INITIALIZED
    # =========================================================================

    - name: "[vault] Get Vault status"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json 2>/dev/null || true
      register: vault_status_raw
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Parse initialization status"
      set_fact:
        vault_is_initialized: "{{ (vault_status_raw.stdout | from_json).initialized | default(false) | bool }}"
      failed_when: false
      ignore_errors: true
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Set default if parse failed"
      set_fact:
        vault_is_initialized: false
      when: vault_is_initialized is not defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show initialization status"
      debug:
        msg: "Vault initialized: {{ vault_is_initialized }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 5: CHECK FOR INTERRUPTED INIT (temp file exists)
    # =========================================================================

    - name: "[vault] Check if init temp file exists"
      stat:
        path: "{{ vault_creds_init_tmp_path }}"
      register: vault_init_tmp_file
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show temp file status"
      debug:
        msg: "Init temp file exists: {{ vault_init_tmp_file.stat.exists }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Set init temp file exists fact"
      set_fact:
        vault_init_tmp_file_exists: "{{ vault_init_tmp_file.stat.exists }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 6: RESUME FROM INTERRUPTED INIT (temp file exists)
    # New flow: distribute FIRST → delete temp → read from main file → unseal
    # =========================================================================

    - name: "[vault-resume] Read credentials from temp file"
      slurp:
        src: "{{ vault_creds_init_tmp_path }}"
      register: vault_tmp_content
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Store temp credentials as fact for distribution"
      set_fact:
        vault_resume_creds:
          root_token: "{{ (vault_tmp_content.content | b64decode | from_json).root_token }}"
          unseal_keys: "{{ (vault_tmp_content.content | b64decode | from_json).unseal_keys }}"
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Show resume info"
      debug:
        msg:
          - "=============================================="
          - "RESUMING from interrupted init"
          - "Distributing credentials to all managers first"
          - "=============================================="
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Broadcast credentials for distribution"
      set_fact:
        _dist_vault_root_token: "{{ hostvars[master_manager_fact].vault_resume_creds.root_token | default('') }}"
        _dist_vault_unseal_keys: "{{ hostvars[master_manager_fact].vault_resume_creds.unseal_keys | default([]) }}"
      when: hostvars[master_manager_fact].vault_init_tmp_file_exists | default(false)

    - name: "[vault-resume] Distribute credentials to all managers"
      include_tasks: tasks/tasks-vault-distribute-creds.yaml
      vars:
        vault_root_token_tmp: "{{ _dist_vault_root_token }}"
        vault_unseal_keys_tmp: "{{ _dist_vault_unseal_keys }}"
        vault_creds_host_path_tmp: "{{ vault_creds_host_path }}"
      when: hostvars[master_manager_fact].vault_init_tmp_file_exists | default(false)

    - name: "[vault-resume] Delete temp file"
      file:
        path: "{{ vault_creds_init_tmp_path }}"
        state: absent
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Read credentials from main file"
      slurp:
        src: "{{ vault_creds_host_path }}"
      register: vault_main_after_resume
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Set credentials from main file"
      set_fact:
        vault_unseal_keys: "{{ (vault_main_after_resume.content | b64decode | from_json).unseal_keys }}"
        vault_root_token: "{{ (vault_main_after_resume.content | b64decode | from_json).root_token }}"
      when:
        - vault_init_tmp_file.stat.exists
        - vault_main_after_resume is not skipped
        - vault_main_after_resume.content is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Check seal status"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json | jq -r '.sealed'
      register: vault_resume_sealed_check
      when: vault_init_tmp_file.stat.exists
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Unseal Vault if sealed"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator unseal {{ key }}
      loop: "{{ vault_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      when:
        - vault_init_tmp_file.stat.exists
        - vault_resume_sealed_check.stdout | default('true') == 'true'
        - vault_unseal_keys is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Show resume complete"
      debug:
        msg: "Resume complete - credentials distributed and Vault unsealed"
      when: vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 7: ALREADY INITIALIZED + NO TEMP FILE (normal case)
    # =========================================================================

    - name: "[vault] Check seal status (initialized, no temp)"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json | jq -r '.sealed'
      register: vault_sealed_check
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show seal status (initialized, no temp)"
      debug:
        msg: "Vault sealed: {{ vault_sealed_check.stdout | default('unknown') }}"
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 7.1: READ CREDENTIALS FROM MAIN FILE (if needed)
    # =========================================================================

    - name: "[vault] Check if main credentials file exists"
      stat:
        path: "{{ vault_creds_host_path }}"
      register: vault_creds_file
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] FAIL if no credentials file found"
      fail:
        msg: |
          =====================================================
          CRITICAL: Vault is initialized but credentials file not found!

          Main file: {{ vault_creds_host_path }} - NOT FOUND
          Temp file: {{ vault_creds_init_tmp_path }} - NOT FOUND

          This means unseal keys and root token are LOST.
          You need to manually recover or reinitialize Vault.
          =====================================================
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
        - not (vault_creds_file.stat.exists | default(false))
      run_once: true

    - name: "[vault] Read credentials from main file"
      slurp:
        src: "{{ vault_creds_host_path }}"
      register: vault_main_creds_content
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
        - vault_creds_file.stat.exists | default(false)
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Parse credentials from main file"
      set_fact:
        vault_unseal_keys: "{{ (vault_main_creds_content.content | b64decode | from_json).unseal_keys }}"
        vault_root_token: "{{ (vault_main_creds_content.content | b64decode | from_json).root_token }}"
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
        - vault_main_creds_content is defined
        - vault_main_creds_content.content is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 7.2: UNSEAL IF SEALED (initialized, no temp)
    # =========================================================================

    - name: "[vault] Unseal Vault with keys from main file"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator unseal {{ key }}
      loop: "{{ vault_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
        - vault_sealed_check.stdout | default('false') == 'true'
        - vault_unseal_keys is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Login with root token (initialized, no temp)"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault login {{ vault_root_token }}
      when:
        - vault_is_initialized | bool
        - not vault_init_tmp_file.stat.exists
        - vault_root_token is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 8: INITIALIZE VAULT (if not initialized)
    # =========================================================================

    - name: "[vault] Initialize Vault"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator init \
          -key-shares={{ vault_key_shares }} \
          -key-threshold={{ vault_key_threshold }} \
          -format=json
      register: vault_init_result
      when: not (vault_is_initialized | bool)
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show initialization header"
      debug:
        msg:
          - "=============================================="
          - "VAULT INITIALIZED — saving to temp file and distributing"
          - "=============================================="
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 8.1: SAVE TO TEMP FILE (fault tolerance checkpoint)
    # =========================================================================

    - name: "[vault-init] Build credentials JSON from init result"
      set_fact:
        vault_init_creds_json:
          root_token: "{{ (vault_init_result.stdout | from_json).root_token }}"
          unseal_keys: "{{ (vault_init_result.stdout | from_json).unseal_keys_b64 }}"
          key_threshold: "{{ vault_key_threshold }}"
      when: vault_init_result is not skipped and vault_init_result.stdout is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Save credentials to temp file"
      copy:
        content: "{{ vault_init_creds_json | to_nice_json }}"
        dest: "{{ vault_creds_init_tmp_path }}"
        mode: "0600"
        owner: root
        group: root
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Show temp file saved"
      debug:
        msg: "Credentials saved to temp file: {{ vault_creds_init_tmp_path }}"
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 9: DISTRIBUTE CREDENTIALS TO ALL MANAGERS (before unseal)
    # Credentials are on all managers BEFORE any vault operations
    # =========================================================================

    - name: "[vault-creds] Broadcast credentials for distribution"
      set_fact:
        _dist_vault_root_token: "{{ hostvars[master_manager_fact].vault_init_creds_json.root_token | default('') }}"
        _dist_vault_unseal_keys: "{{ hostvars[master_manager_fact].vault_init_creds_json.unseal_keys | default([]) }}"
      when: hostvars[master_manager_fact].vault_init_creds_json is defined

    - name: "[vault-creds] Distribute credentials to all managers (after init)"
      include_tasks: tasks/tasks-vault-distribute-creds.yaml
      vars:
        vault_root_token_tmp: "{{ _dist_vault_root_token }}"
        vault_unseal_keys_tmp: "{{ _dist_vault_unseal_keys }}"
        vault_creds_host_path_tmp: "{{ vault_creds_host_path }}"
      when: hostvars[master_manager_fact].vault_init_creds_json is defined

    # =========================================================================
    # STEP 9.1: DELETE TEMP FILE (after successful distribution)
    # =========================================================================

    - name: "[vault-init] Delete temp file after successful distribution"
      file:
        path: "{{ vault_creds_init_tmp_path }}"
        state: absent
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Show temp file deleted"
      debug:
        msg: "Temp file deleted: {{ vault_creds_init_tmp_path }}"
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 9.2: READ FROM MAIN FILE → set_fact (always from file, not stdout)
    # =========================================================================

    - name: "[vault-init] Read credentials from main file"
      slurp:
        src: "{{ vault_creds_host_path }}"
      register: vault_creds_from_file
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Set credentials from main file"
      set_fact:
        vault_unseal_keys: "{{ (vault_creds_from_file.content | b64decode | from_json).unseal_keys }}"
        vault_root_token: "{{ (vault_creds_from_file.content | b64decode | from_json).root_token }}"
      when:
        - vault_init_result is not skipped
        - vault_creds_from_file is not skipped
        - vault_creds_from_file.content is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Show unseal keys (from main file)"
      debug:
        msg: "Unseal Key {{ idx + 1 }}: {{ key }}"
      loop: "{{ vault_unseal_keys | default([]) }}"
      loop_control:
        index_var: idx
        loop_var: key
      when: vault_init_result is not skipped and vault_unseal_keys is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-init] Show root token (from main file)"
      debug:
        msg:
          - "Root Token: {{ vault_root_token }}"
          - "=============================================="
          - "Credentials distributed to: {{ groups['managers'] | join(', ') }}"
          - "File: {{ vault_creds_host_path }}"
          - "=============================================="
      when: vault_init_result is not skipped and vault_root_token is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 9.3: UNSEAL VAULT (after distribution and file read)
    # =========================================================================

    - name: "[vault] Unseal Vault ({{ vault_key_threshold }} keys required)"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator unseal {{ key }}
      loop: "{{ vault_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      when:
        - vault_init_result is not skipped
        - vault_unseal_keys is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # COMMON: Verify seal status (used for policy sync condition)
    # =========================================================================

    - name: "[vault] Verify Vault is unsealed"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json | jq -r '.sealed'
      register: vault_sealed_status
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show seal status"
      debug:
        msg: "Vault sealed: {{ vault_sealed_status.stdout }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 10: CONFIGURE KUBERNETES AUTH (if just initialized)
    # =========================================================================

    - name: "[vault] Login with root token"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault login {{ vault_root_token }}
      when: vault_root_token is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Enable Kubernetes auth method"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault auth enable kubernetes
      register: k8s_auth_result
      failed_when: false
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Configure Kubernetes auth"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault write auth/kubernetes/config
        kubernetes_host="{{ vault_kubernetes_host }}"
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 11: ENABLE KV SECRETS ENGINE (if just initialized)
    # =========================================================================

    - name: "[vault] Enable KV secrets engines"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault secrets enable -path={{ item }} kv-v2
      loop: "{{ vault_kv_engines }}"
      register: kv_enable_result
      failed_when: false
      when: vault_init_result is not skipped
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 12: SYNC VAULT POLICIES AND ROLES (only when unsealed)
    # =========================================================================

    - name: "[vault-policy-sync] Sync policies and roles from hosts.yaml"
      include_tasks: tasks/tasks-vault-policy-sync.yaml
      when: vault_sealed_status.stdout | default('true') == 'false'

    # =========================================================================
    # STEP 13: INSTALL POST (Ingress + CronJob)
    # =========================================================================

    - name: "[vault-post] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "vault-post"
        chart_name: "post"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/vault/post/"
        chart_remote_dest: "{{ remote_charts_dir }}/vault/post"

    - name: "[vault-post] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/vault/post/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ vault_namespace }}
          clusterDomain: {{ dns_domain }}
          ingress:
            ingressClass: {{ traefik_ingress_class }}
            entrypoint: {{ traefik_websecure_entrypoint }}
            domain: {{ vault_domain }}
            clusterIssuer: {{ cert_manager_cluster_issuer }}
            secretName: {{ vault_https_secret_name }}
            vpnOnlyEnabled: {{ vault_vpn_only_enabled }}
          traefik:
            namespace: {{ traefik_namespace }}
          eso:
            saName: {{ vault_eso.sa_name }}
            roleName: {{ vault_eso.role_name }}
            secretStoreName: {{ vault_eso.secret_store_name }}
            kvEnginePath: {{ vault_eso.kv_engine_path }}
            secrets: {{ vault_eso.secrets | to_json }}
          autoUnseal:
            schedule: "{{ vault_auto_unseal_schedule }}"
            keyThreshold: {{ vault_key_threshold }}
            credsHostPath: "{{ vault_creds_host_path }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-post] Install via Helm"
      command: >
        helm upgrade --install vault-post {{ remote_charts_dir }}/vault/post
        --namespace {{ vault_namespace }}
        --values {{ remote_charts_dir }}/vault/post/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ vault_config_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 14: VERIFY AND OUTPUT
    # =========================================================================

    - name: "[vault-verify] Verify Helm releases"
      include_tasks: tasks/tasks-verify-helm.yaml
      vars:
        helm_namespace: "{{ vault_namespace }}"
        label_name: "vault-verify"

    - name: "[vault-credentials] Show credentials header"
      debug:
        msg:
          - "=============================================="
          - "VAULT CREDENTIALS"
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-credentials] Show unseal keys"
      debug:
        msg: "Unseal Key {{ idx + 1 }}: {{ key }}"
      loop: "{{ vault_unseal_keys | default([]) }}"
      loop_control:
        index_var: idx
        loop_var: key
      when: vault_unseal_keys is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-credentials] Show unseal keys (already initialized)"
      debug:
        msg: "Unseal Keys: (already initialized - check {{ vault_creds_host_path }})"
      when: vault_unseal_keys is not defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-credentials] Show remaining info"
      debug:
        msg:
          - "Root Token: {{ vault_root_token | default('(already initialized)') }}"
          - ""
          - "Credentials saved to:"
          - "  Path: {{ vault_creds_host_path }}"
          - "  Distributed to: {{ groups['managers'] | join(', ') }}"
          - ""
          - "Vault UI: https://{{ vault_domain }}"
          - "VPN-only: {{ vault_vpn_only_enabled }}"
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-verify] Confirm installation"
      debug:
        msg: "Vault installation: OK"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true
