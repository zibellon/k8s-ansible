# =============================================================================
# GITLAB INSTALLATION (Production Helm Chart)
# =============================================================================
# Prerequisites:
#   - Vault must be installed and unsealed
#   - Vault policies and roles must be synced (vault-policy-sync.yaml)
#   - External Secrets Operator must be installed
#
# This playbook:
#   1. Creates initial secrets in Vault (PostgreSQL, Redis, MinIO root)
#   2. Installs ESO resources (ServiceAccount, SecretStore, ExternalSecrets)
#   3. Waits for ESO to sync credentials
#   4. Installs PostgreSQL
#   5. Installs Redis
#   6. Installs MinIO
#   7. Creates MinIO buckets and access keys
#   8. Stores MinIO access keys in Vault
#   9. Installs GitLab (official Helm chart)
#   10. Stores GitLab root password in Vault
#   11. Installs GitLab Runner (without registration)
#
# =============================================================================

---
- name: Install GitLab (Production Helm)
  hosts: managers
  become: true
  gather_facts: false

  tasks:
    - name: "[gitlab-pre-check] Validate target"
      include_tasks: tasks/tasks-pre-check.yaml
      vars:
        label_name: "gitlab-pre-check"

    # =========================================================================
    # INIT: Merge ESO integrations and resolve GitLab config
    # =========================================================================

    - name: "[gitlab-install-init] Merge ESO integrations"
      include_tasks: tasks/tasks-eso-merge.yaml

    - name: "[gitlab-install-init] Set gitlab_eso from merged integration"
      set_fact:
        gitlab_eso: "{{ eso_vault_integration_gitlab_merged }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-install-init] Find secret names and vault paths by type"
      set_fact:
        # Secret names
        secret_postgresql: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'postgresql') | first).target_secret_name }}"
        secret_redis: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'redis') | first).target_secret_name }}"
        secret_minio_root: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_root') | first).target_secret_name }}"
        secret_minio_registry: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_registry') | first).target_secret_name }}"
        secret_gitlab_registry_minio_connection: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'gitlab_registry_minio_connection') | first).target_secret_name }}"
        secret_gitlab_minio_connection: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'gitlab_minio_connection') | first).target_secret_name }}"
        secret_minio_runner_cache: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_runner_cache') | first).target_secret_name }}"
        secret_gitlab_root: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'gitlab_root') | first).target_secret_name }}"
        # Vault paths
        vault_path_postgresql: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'postgresql') | first).vault_path }}"
        vault_path_redis: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'redis') | first).vault_path }}"
        vault_path_minio_root: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_root') | first).vault_path }}"
        vault_path_minio_registry: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_registry') | first).vault_path }}"
        vault_path_minio_runner_cache: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'minio_runner_cache') | first).vault_path }}"
        vault_path_gitlab_root: "{{ (gitlab_eso.secrets | selectattr('type', 'equalto', 'gitlab_root') | first).vault_path }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 1: GENERATE AND STORE INITIAL SECRETS IN VAULT
    # =========================================================================

    # ----- PostgreSQL credentials -----
    - name: "[gitlab-vault-secrets] Check if PostgreSQL secret exists"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_postgresql }} 2>/dev/null
      register: postgresql_secret_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Generate PostgreSQL password"
      set_fact:
        generated_postgresql_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"
      when: postgresql_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Store PostgreSQL credentials in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_postgresql }}
        username=gitlab
        password={{ generated_postgresql_password }}
      when: postgresql_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # ----- Redis credentials -----
    - name: "[gitlab-vault-secrets] Check if Redis secret exists"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_redis }} 2>/dev/null
      register: redis_secret_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Generate Redis password"
      set_fact:
        generated_redis_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"
      when: redis_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Store Redis credentials in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_redis }}
        password={{ generated_redis_password }}
        redis_args="--save 1 1 --notify-keyspace-events KEA --requirepass {{ generated_redis_password }}"
      when: redis_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # ----- MinIO root credentials -----
    - name: "[gitlab-vault-secrets] Check if MinIO root secret exists"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_root }} 2>/dev/null
      register: minio_root_secret_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Generate MinIO root password"
      set_fact:
        generated_minio_password: "{{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}"
      when: minio_root_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-vault-secrets] Store MinIO root credentials in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_root }}
        username={{ gitlab_minio_root_user }}
        password={{ generated_minio_password }}
      when: minio_root_secret_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 3: INSTALL PRE (ESO Resources, NetworkPolicies)
    # =========================================================================

    - name: "[gitlab-pre] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "gitlab-pre"
        chart_name: "pre"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/gitlab/pre/"
        chart_remote_dest: "{{ remote_charts_dir }}/gitlab/pre"

    - name: "[gitlab-pre] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/pre/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ gitlab_namespace }}
          clusterDomain: {{ dns_domain }}
          vault:
            namespace: {{ vault_namespace }}
          externalSecrets:
            namespace: {{ external_secrets_namespace }}
          traefik:
            namespace: {{ traefik_namespace }}
            instanceName: traefik-{{ traefik_namespace }}
          haproxy:
            namespace: {{ haproxy_namespace }}
            ingressClass: {{ haproxy_ingress_class }}
          gitlab:
            releaseName: gitlab
          gitlabEso:
            saName: {{ gitlab_eso.sa_name }}
            roleName: {{ gitlab_eso.role_name }}
            secretStoreName: {{ gitlab_eso.secret_store_name }}
            kvEnginePath: {{ gitlab_eso.kv_engine_path }}
            secrets: {{ gitlab_eso.secrets | to_json }}
          minio:
            s3Endpoint: {{ gitlab_minio_s3_endpoint }}
            s3Region: {{ gitlab_minio_s3_region }}
            s3PathStyle: {{ gitlab_minio_s3_path_style }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-pre] Install via Helm"
      command: >
        helm upgrade --install gitlab-pre {{ remote_charts_dir }}/gitlab/pre
        --namespace {{ gitlab_namespace }}
        --create-namespace
        --values {{ remote_charts_dir }}/gitlab/pre/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_pre_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 4: WAIT FOR INITIAL SECRETS TO SYNC
    # =========================================================================

    - name: "[gitlab-wait-eso] Force sync initial secrets"
      command: >
        kubectl annotate externalsecret {{ item }}
        -n {{ gitlab_namespace }}
        force-sync={{ lookup('pipe', 'date +%s') }} --overwrite
      loop: >-
        {{
          gitlab_eso.secrets
          | selectattr('type', 'in', ['postgresql', 'redis', 'minio_root'])
          | map(attribute='external_secret_name')
          | list
        }}
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-wait-eso] Wait for PostgreSQL secret"
      command: kubectl get secret {{ secret_postgresql }} -n {{ gitlab_namespace }}
      register: postgresql_secret_wait
      until: postgresql_secret_wait.rc == 0
      retries: 30
      delay: 5
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-wait-eso] Wait for Redis secret"
      command: kubectl get secret {{ secret_redis }} -n {{ gitlab_namespace }}
      register: redis_secret_wait
      until: redis_secret_wait.rc == 0
      retries: 30
      delay: 5
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-wait-eso] Wait for MinIO root secret"
      command: kubectl get secret {{ secret_minio_root }} -n {{ gitlab_namespace }}
      register: minio_root_secret_wait
      until: minio_root_secret_wait.rc == 0
      retries: 30
      delay: 5
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 5: INSTALL POSTGRESQL
    # =========================================================================

    - name: "[gitlab-postgresql] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "gitlab-postgresql"
        chart_name: "postgresql"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/gitlab/postgresql/"
        chart_remote_dest: "{{ remote_charts_dir }}/gitlab/postgresql"

    - name: "[gitlab-postgresql] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/postgresql/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ gitlab_namespace }}
          image: {{ gitlab_postgresql_image }}
          storageClass: {{ gitlab_postgresql_storage_class }}
          storageSize: {{ gitlab_postgresql_storage_size }}
          credentialsSecretName: {{ secret_postgresql }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-postgresql] Install via Helm"
      command: >
        helm upgrade --install gitlab-postgresql {{ remote_charts_dir }}/gitlab/postgresql
        --namespace {{ gitlab_namespace }}
        --values {{ remote_charts_dir }}/gitlab/postgresql/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_storage_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-postgresql] Wait for rollout to be ready"
      include_tasks: tasks/tasks-wait-rollout.yaml
      vars:
        label_name: "gitlab-postgresql"
        rollout_namespace: "{{ gitlab_namespace }}"
        rollout_timeout: "{{ gitlab_storage_rollout_timeout }}"
        rollout_resources:
          - deployment/gitlab-postgresql

    # =========================================================================
    # STEP 6: INSTALL REDIS
    # =========================================================================

    - name: "[gitlab-redis] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "gitlab-redis"
        chart_name: "redis"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/gitlab/redis/"
        chart_remote_dest: "{{ remote_charts_dir }}/gitlab/redis"

    - name: "[gitlab-redis] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/redis/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ gitlab_namespace }}
          image: {{ gitlab_redis_image }}
          credentialsSecretName: {{ secret_redis }}
          storageClass: {{ gitlab_redis_storage_class }}
          storageSize: {{ gitlab_redis_storage_size }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-redis] Install via Helm"
      command: >
        helm upgrade --install gitlab-redis {{ remote_charts_dir }}/gitlab/redis
        --namespace {{ gitlab_namespace }}
        --values {{ remote_charts_dir }}/gitlab/redis/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_storage_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-redis] Wait for rollout to be ready"
      include_tasks: tasks/tasks-wait-rollout.yaml
      vars:
        label_name: "gitlab-redis"
        rollout_namespace: "{{ gitlab_namespace }}"
        rollout_timeout: "{{ gitlab_storage_rollout_timeout }}"
        rollout_resources:
          - deployment/gitlab-redis

    # =========================================================================
    # STEP 7: INSTALL MINIO
    # =========================================================================

    - name: "[gitlab-minio] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "gitlab-minio"
        chart_name: "minio"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/gitlab/minio/"
        chart_remote_dest: "{{ remote_charts_dir }}/gitlab/minio"

    - name: "[gitlab-minio] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/minio/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ gitlab_namespace }}
          image: {{ gitlab_minio_image }}
          storageClass: {{ gitlab_minio_storage_class }}
          storageSize: {{ gitlab_minio_storage_size }}
          rootSecretName: {{ secret_minio_root }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio] Install via Helm"
      command: >
        helm upgrade --install gitlab-minio {{ remote_charts_dir }}/gitlab/minio
        --namespace {{ gitlab_namespace }}
        --values {{ remote_charts_dir }}/gitlab/minio/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_storage_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio] Wait for rollout to be ready"
      include_tasks: tasks/tasks-wait-rollout.yaml
      vars:
        label_name: "gitlab-minio"
        rollout_namespace: "{{ gitlab_namespace }}"
        rollout_timeout: "{{ gitlab_storage_rollout_timeout }}"
        rollout_resources:
          - deployment/gitlab-minio

    # =========================================================================
    # STEP 8: MINIO SETUP (Buckets and Access Keys)
    # =========================================================================

    - name: "[gitlab-minio-setup] Get MinIO pod name"
      command: >
        kubectl get pods -n {{ gitlab_namespace }}
        -l app.kubernetes.io/name=gitlab-minio
        -o jsonpath='{.items[0].metadata.name}'
      register: minio_pod_name
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Get MinIO root credentials from secret"
      shell: |
        kubectl get secret {{ secret_minio_root }} -n {{ gitlab_namespace }} \
          -o jsonpath='{.data.username}' | base64 -d
      register: minio_root_user_from_secret
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Get MinIO root password from secret"
      shell: |
        kubectl get secret {{ secret_minio_root }} -n {{ gitlab_namespace }} \
          -o jsonpath='{.data.password}' | base64 -d
      register: minio_root_password_from_secret
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Configure mc alias"
      command: >
        kubectl exec -n {{ gitlab_namespace }} {{ minio_pod_name.stdout }} --
        mc alias set myminio http://localhost:9000
        '{{ minio_root_user_from_secret.stdout }}'
        '{{ minio_root_password_from_secret.stdout }}'
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # Create buckets
    - name: "[gitlab-minio-setup] Create buckets"
      command: >
        kubectl exec -n {{ gitlab_namespace }} {{ minio_pod_name.stdout }} --
        mc mb myminio/{{ item }} --ignore-existing
      loop:
        - registry
        - gitlab-artifacts
        - gitlab-uploads
        - gitlab-packages
        - gitlab-backups
        - runner-cache
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # Create access keys for registry
    - name: "[gitlab-minio-setup] Check if registry access_key exists in Vault"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_registry }} 2>/dev/null \
          | jq -r '.data.data.access_key // empty'
      register: registry_access_key_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Create access key for registry"
      command: >
        kubectl exec -n {{ gitlab_namespace }} {{ minio_pod_name.stdout }} --
        mc admin accesskey create myminio {{ minio_root_user_from_secret.stdout }}
        --name 'registry-key' --json
      register: registry_accesskey_result
      when: registry_access_key_check.stdout == ""
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Store registry access key in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_registry }}
        access_key={{ (registry_accesskey_result.stdout | from_json).accessKey }}
        secret_key={{ (registry_accesskey_result.stdout | from_json).secretKey }}
        bucket_name=registry
      when: registry_access_key_check.stdout == ""
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # Create access keys for runner-cache
    - name: "[gitlab-minio-setup] Check if runner-cache access_key exists in Vault"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_runner_cache }} 2>/dev/null \
          | jq -r '.data.data.access_key // empty'
      register: runner_cache_access_key_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Create access key for runner-cache"
      command: >
        kubectl exec -n {{ gitlab_namespace }} {{ minio_pod_name.stdout }} --
        mc admin accesskey create myminio {{ minio_root_user_from_secret.stdout }}
        --name 'runner-cache-key' --json
      register: runner_cache_accesskey_result
      when: runner_cache_access_key_check.stdout == ""
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-minio-setup] Parse and store runner-cache access key in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_runner_cache }}
        access_key={{ (runner_cache_accesskey_result.stdout | from_json).accessKey }}
        secret_key={{ (runner_cache_accesskey_result.stdout | from_json).secretKey }}
        bucket_name=runner-cache
      when: runner_cache_access_key_check.stdout == ""
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 9: WAIT FOR MINIO ACCESS KEYS TO SYNC
    # =========================================================================

    - name: "[gitlab-wait-eso] Force sync MinIO access key secrets"
      command: >
        kubectl annotate externalsecret {{ item }}
        -n {{ gitlab_namespace }}
        force-sync={{ lookup('pipe', 'date +%s') }} --overwrite
      loop: >-
        {{
          gitlab_eso.secrets
          | selectattr('type', 'in', ['minio_registry', 'minio_runner_cache', 'gitlab_registry_minio_connection', 'gitlab_minio_connection'])
          | map(attribute='external_secret_name')
          | list
        }}
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-wait-eso] Wait for registry secret with access_key"
      shell: |
        kubectl get secret {{ secret_minio_registry }} -n {{ gitlab_namespace }} \
          -o jsonpath='{.data.access_key}' | base64 -d
      register: registry_access_key_sync_check
      until: registry_access_key_sync_check.stdout != ""
      retries: 30
      delay: 5
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 10: INSTALL GITLAB (Official Helm Chart)
    # =========================================================================

    - name: "[gitlab] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/gitlab-values-override.yaml"
        mode: "0644"
        content: |
          global:
            edition: ce
            hosts:
              domain: {{ gitlab_base_domain }}
              https: true
              gitlab:
                name: {{ gitlab_domain }}
                https: true
              registry:
                name: {{ gitlab_registry_domain }}
                https: true
              pages:
                name: {{ gitlab_pages_domain }}
                https: true
            ingress:
              enabled: false
              configureCertmanager: false
            shell:
              port: {{ gitlab_ssh_port_external }}
            psql:
              host: svc-gitlab-postgresql
              port: 5432
              database: gitlabhq_production
              username: gitlab
              password:
                useSecret: true
                secret: {{ secret_postgresql }}
                key: password
            redis:
              host: svc-gitlab-redis
              port: 6379
              auth:
                enabled: true
                secret: {{ secret_redis }}
                key: password
            minio:
              enabled: false
            registry:
              bucket: registry
            kas:
              enabled: false
            pages:
              enabled: true
            appConfig:
              lfs:
                enabled: false
              object_store:
                enabled: true
                proxy_download: true
                connection:
                  secret: {{ secret_gitlab_minio_connection }}
                  key: connection
              artifacts:
                enabled: true
                bucket: gitlab-artifacts
              uploads:
                enabled: true
                bucket: gitlab-uploads
              packages:
                enabled: true
                bucket: gitlab-packages
              backups:
                bucket: gitlab-backups
            smtp:
              enabled: false
          nginx-ingress:
            enabled: false
          certmanager:
            install: false
          prometheus:
            install: false
          postgresql:
            install: false
          redis:
            install: false
          registry:
            enabled: true
            hpa:
              minReplicas: 1
              maxReplicas: 2
            storage:
              secret: {{ secret_gitlab_registry_minio_connection }}
              key: config
              redirect:
                disable: true
          gitlab:
            webservice:
              minReplicas: 1
              maxReplicas: 2
              workerProcesses: 2
              workerTimeout: 180
              resources:
                requests:
                  memory: {{ gitlab_webservice_memory_request }}
                  cpu: {{ gitlab_webservice_cpu_request }}
                limits:
                  memory: {{ gitlab_webservice_memory_limit }}
            sidekiq:
              minReplicas: 1
              maxReplicas: 2
              concurrency: 10
              resources:
                requests:
                  memory: {{ gitlab_sidekiq_memory_request }}
                  cpu: {{ gitlab_sidekiq_cpu_request }}
                limits:
                  memory: {{ gitlab_sidekiq_memory_limit }}
            gitlab-shell:
              minReplicas: 1
              maxReplicas: 2
            gitaly:
              persistence:
                size: {{ gitlab_gitaly_storage_size }}
                storageClass: {{ gitlab_gitaly_storage_class }}
            toolbox:
              enabled: true
            migrations:
              enabled: true
          gitlab-runner:
            install: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab] Add Helm repository"
      include_tasks: tasks/tasks-add-helm-repo.yaml
      vars:
        label_name: "gitlab"
        helm_repo_name: "gitlab"
        helm_repo_url: "https://charts.gitlab.io"

    - name: "[gitlab] Install via Helm"
      command: >
        helm upgrade --install gitlab gitlab/gitlab
        --namespace {{ gitlab_namespace }}
        --values {{ remote_charts_dir }}/gitlab/gitlab-values-override.yaml
        --version {{ gitlab_chart_version }}
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab] Wait for webservice deployment to be ready"
      command: >
        kubectl rollout status deployment -l app=webservice
        -n {{ gitlab_namespace }}
        --timeout={{ gitlab_rollout_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 11: SAVE GITLAB ROOT PASSWORD TO VAULT
    # =========================================================================

    - name: "[gitlab-root] Check if root password exists in Vault"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -format=json \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_gitlab_root }} 2>/dev/null
      register: gitlab_root_vault_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-root] Get root password from Kubernetes secret"
      shell: |
        kubectl get secret gitlab-gitlab-initial-root-password \
          -n {{ gitlab_namespace }} \
          -o jsonpath='{.data.password}' | base64 -d
      register: gitlab_root_password_result
      when: gitlab_root_vault_check.rc != 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-root] Store root password in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv put {{ gitlab_eso.kv_engine_path }}{{ vault_path_gitlab_root }}
        username=root
        password={{ gitlab_root_password_result.stdout }}
      when:
        - gitlab_root_vault_check.rc != 0
        - gitlab_root_password_result.stdout is defined
        - gitlab_root_password_result.stdout | length > 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 12: CREATE GITLAB ROOT PAT (for API access by other playbooks)
    # =========================================================================

    - name: "[gitlab-root-pat] Check if root PAT token exists in Vault"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- \
          vault kv get -field=token \
          {{ gitlab_eso.kv_engine_path }}{{ vault_path_gitlab_root }} 2>/dev/null || true
      register: gitlab_root_pat_check
      failed_when: false
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-root-pat] Get GitLab toolbox pod name"
      command: >
        kubectl get pods -n {{ gitlab_namespace }}
        -l app=toolbox
        -o jsonpath='{.items[0].metadata.name}'
      register: gitlab_pod_name
      when: gitlab_root_pat_check.stdout | trim | length == 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-root-pat] Create root PAT via gitlab-rails runner"
      shell: |
        kubectl exec -n {{ gitlab_namespace }} {{ gitlab_pod_name.stdout }} -- \
          gitlab-rails runner \
          "token = User.find_by_username('root').personal_access_tokens.create(scopes: ['api'], name: 'gitlab-root', expires_at: 365.days.from_now); puts token.token"
      register: gitlab_root_pat_result
      when: gitlab_root_pat_check.stdout | trim | length == 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-root-pat] Store root PAT token in Vault"
      command: >
        kubectl exec -n {{ vault_namespace }} vault-0 --
        vault kv patch {{ gitlab_eso.kv_engine_path }}{{ vault_path_gitlab_root }}
        token={{ gitlab_root_pat_result.stdout | trim }}
      when:
        - gitlab_root_pat_check.stdout | trim | length == 0
        - gitlab_root_pat_result.stdout is defined
        - gitlab_root_pat_result.stdout | trim | length > 0
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 13: INSTALL POST CHART (Ingress, HAProxy SSH)
    # =========================================================================

    - name: "[gitlab-post] Copy chart to remote"
      include_tasks: tasks/tasks-copy-chart.yaml
      vars:
        label_name: "gitlab-post"
        chart_name: "post"
        chart_local_src: "{{ inventory_dir }}/playbook-app/charts/gitlab/post/"
        chart_remote_dest: "{{ remote_charts_dir }}/gitlab/post"

    - name: "[gitlab-post] Create values file"
      copy:
        dest: "{{ remote_charts_dir }}/gitlab/post/values-override.yaml"
        mode: "0644"
        content: |
          namespace: {{ gitlab_namespace }}
          sshPortExternal: {{ gitlab_ssh_port_external }}
          gitlab:
            ingressClass: {{ traefik_ingress_class }}
            entrypoint: {{ traefik_websecure_entrypoint }}
            domain: {{ gitlab_domain }}
            registryDomain: {{ gitlab_registry_domain }}
            pagesDomain: {{ gitlab_pages_domain }}
            clusterIssuer: {{ cert_manager_cluster_issuer }}
            secretName: {{ gitlab_https_secret_name }}
            vpnOnlyEnabled: {{ gitlab_vpn_only_enabled }}
          traefik:
            namespace: {{ traefik_namespace }}
          minio:
            ingressClass: {{ traefik_ingress_class }}
            entrypoint: {{ traefik_websecure_entrypoint }}
            consoleDomain: {{ gitlab_minio_console_domain }}
            apiDomain: {{ gitlab_minio_api_domain }}
            clusterIssuer: {{ cert_manager_cluster_issuer }}
            secretName: {{ gitlab_minio_secret_name }}
            vpnOnlyEnabled: {{ gitlab_vpn_only_enabled }}
          haproxy:
            namespace: {{ haproxy_namespace }}
            ingressClass: {{ haproxy_ingress_class }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[gitlab-post] Install via Helm"
      command: >
        helm upgrade --install gitlab-post {{ remote_charts_dir }}/gitlab/post
        --namespace {{ gitlab_namespace }}
        --values {{ remote_charts_dir }}/gitlab/post/values-override.yaml
        --cleanup-on-fail
        --atomic
        --wait
        --timeout {{ gitlab_helm_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 13: VERIFICATION
    # =========================================================================

    - name: "[gitlab-verify] Verify Helm releases"
      include_tasks: tasks/tasks-verify-helm.yaml
      vars:
        helm_namespace: "{{ gitlab_namespace }}"
        label_name: "gitlab-verify"

    - name: "[gitlab-verify] Show access info"
      debug:
        msg:
          - "=============================================="
          - "GITLAB INSTALLATION COMPLETE"
          - "=============================================="
          - "GitLab Web UI: https://{{ gitlab_domain }}"
          - "GitLab Registry: https://{{ gitlab_registry_domain }}"
          - "GitLab Pages: https://{{ gitlab_pages_domain }}"
          - "GitLab SSH: {{ gitlab_domain }}:{{ gitlab_ssh_port_external }}"
          - ""
          - "Credentials stored in Vault:"
          - "  GitLab root: {{ gitlab_eso.kv_engine_path }}{{ vault_path_gitlab_root }}"
          - "  PostgreSQL: {{ gitlab_eso.kv_engine_path }}{{ vault_path_postgresql }}"
          - "  Redis: {{ gitlab_eso.kv_engine_path }}{{ vault_path_redis }}"
          - "  MinIO root: {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_root }}"
          - "  MinIO registry: {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_registry }}"
          - "  MinIO runner-cache: {{ gitlab_eso.kv_engine_path }}{{ vault_path_minio_runner_cache }}"
          - ""
          - "GitLab Runner: Installed but NOT registered."
          - "  Register manually via UI or CLI."
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true
