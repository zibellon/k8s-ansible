# =============================================================================
# Rotate Vault Unseal Keys (Rekey)
# =============================================================================
# This playbook performs Vault rekey operation to generate new unseal keys
# and distributes them to all control-plane nodes.
#
# Usage:
#   ansible-playbook -i hosts.yaml playbook-app/vault-rotate.yaml
#
# Prerequisites:
#   - Vault must be running
#   - Credentials file must exist at vault_creds_host_path
# =============================================================================
# Fault tolerance: uses temp file to resume from interrupted rotate
# - If rotate temp file exists: resume from interrupted rotate
# - If no temp file: perform fresh rekey
# =============================================================================

---
- name: Rotate Vault Unseal Keys
  hosts: managers
  become: true
  gather_facts: false

  tasks:
    - name: "[vault-rotate-pre-check] Validate target"
      include_tasks: tasks/tasks-pre-check.yaml
      vars:
        label_name: "vault-rotate-pre-check"

    # =========================================================================
    # STEP 1: CHECK VAULT STATUS
    # =========================================================================

    - name: "[vault] Wait for pod to be Running"
      command: >
        kubectl wait --for=jsonpath='{.status.phase}'=Running
        pod/vault-0 -n {{ vault_namespace }}
        --timeout={{ vault_rollout_timeout }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Get Vault status"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json
      register: vault_status
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Parse status"
      set_fact:
        vault_is_sealed: "{{ (vault_status.stdout | from_json).sealed }}"
        vault_is_initialized: "{{ (vault_status.stdout | from_json).initialized }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Fail if not initialized"
      fail:
        msg: "Vault is not initialized. Run vault-install.yaml first."
      when: not (vault_is_initialized | bool)
      run_once: true

    - name: "[vault] Show current status"
      debug:
        msg: "Vault status: initialized={{ vault_is_initialized }}, sealed={{ vault_is_sealed }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 2: CHECK FOR INTERRUPTED ROTATE (temp file exists)
    # =========================================================================

    - name: "[vault] Check if rotate temp file exists"
      stat:
        path: "{{ vault_creds_rotate_tmp_path }}"
      register: vault_rotate_tmp_file
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show temp file status"
      debug:
        msg: "Rotate temp file exists: {{ vault_rotate_tmp_file.stat.exists }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Set rotate temp file exists fact"
      set_fact:
        vault_rotate_tmp_file_exists: "{{ vault_rotate_tmp_file.stat.exists }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 3: RESUME FROM INTERRUPTED ROTATE (temp file exists)
    # =========================================================================

    - name: "[vault-resume] Read credentials from rotate temp file"
      slurp:
        src: "{{ vault_creds_rotate_tmp_path }}"
      register: vault_rotate_tmp_content
      when: vault_rotate_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Parse credentials from temp file"
      set_fact:
        new_unseal_keys: "{{ (vault_rotate_tmp_content.content | b64decode | from_json).unseal_keys }}"
        current_root_token: "{{ (vault_rotate_tmp_content.content | b64decode | from_json).root_token }}"
      when: vault_rotate_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Show resume info"
      debug:
        msg:
          - "=============================================="
          - "RESUMING from interrupted rotate"
          - "Using new keys from temp file"
          - "=============================================="
      when: vault_rotate_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Unseal Vault with new keys"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator unseal {{ key }}
      loop: "{{ new_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      when:
        - vault_rotate_tmp_file.stat.exists
        - vault_is_sealed | bool
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Broadcast credentials to all managers"
      set_fact:
        _dist_current_root_token: "{{ hostvars[master_manager_fact].current_root_token | default('') }}"
        _dist_new_unseal_keys: "{{ hostvars[master_manager_fact].new_unseal_keys | default([]) }}"
      when: hostvars[master_manager_fact].vault_rotate_tmp_file_exists | default(false)

    - name: "[vault-resume] Distribute new credentials to all managers"
      include_tasks: tasks/tasks-vault-distribute-creds.yaml
      vars:
        vault_root_token_tmp: "{{ _dist_current_root_token }}"
        vault_unseal_keys_tmp: "{{ _dist_new_unseal_keys }}"
        vault_creds_host_path_tmp: "{{ vault_creds_host_path }}"
      when: hostvars[master_manager_fact].vault_rotate_tmp_file_exists | default(false)

    - name: "[vault-resume] Delete rotate temp file"
      file:
        path: "{{ vault_creds_rotate_tmp_path }}"
        state: absent
      when: vault_rotate_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] Show resume complete"
      debug:
        msg:
          - "=============================================="
          - "VAULT REKEY RESUMED SUCCESSFULLY"
          - "=============================================="
          - "New credentials distributed to: {{ groups['managers'] | join(', ') }}"
          - "Credentials file: {{ vault_creds_host_path }}"
          - "=============================================="
      when: vault_rotate_tmp_file.stat.exists
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault-resume] End play if resumed"
      meta: end_play
      when: vault_rotate_tmp_file.stat.exists

    # =========================================================================
    # STEP 4: READ CURRENT CREDENTIALS (fresh rotate)
    # =========================================================================

    - name: "[vault] Check if credentials file exists"
      stat:
        path: "{{ vault_creds_host_path }}"
      register: vault_creds_file
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Fail if no credentials file"
      fail:
        msg: "Credentials file not found at {{ vault_creds_host_path }}. Cannot perform rekey."
      when: not vault_creds_file.stat.exists
      run_once: true

    - name: "[vault] Read current credentials"
      slurp:
        src: "{{ vault_creds_host_path }}"
      register: vault_creds_content
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Parse current credentials"
      set_fact:
        current_unseal_keys: "{{ (vault_creds_content.content | b64decode | from_json).unseal_keys }}"
        current_root_token: "{{ (vault_creds_content.content | b64decode | from_json).root_token }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Show current credentials loaded"
      debug:
        msg: "Loaded {{ current_unseal_keys | length }} unseal keys from {{ vault_creds_host_path }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 5: UNSEAL IF NEEDED (with current keys)
    # =========================================================================

    - name: "[vault] Unseal Vault (if sealed)"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator unseal {{ key }}
      loop: "{{ current_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      when: vault_is_sealed | bool
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Verify unsealed"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json | jq -r '.sealed'
      register: vault_sealed_after
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[vault] Fail if still sealed"
      fail:
        msg: "Failed to unseal Vault"
      when: vault_sealed_after.stdout == 'true'
      run_once: true

    # =========================================================================
    # STEP 6: PERFORM REKEY
    # =========================================================================

    - name: "[vault] Login with root token"
      command: kubectl exec -n {{ vault_namespace }} vault-0 -- vault login {{ current_root_token }}
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Initialize rekey operation"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator rekey \
          -init \
          -key-shares={{ vault_key_shares }} \
          -key-threshold={{ vault_key_threshold }} \
          -format=json
      register: rekey_init
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Parse rekey nonce"
      set_fact:
        rekey_nonce: "{{ (rekey_init.stdout | from_json).nonce }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Show rekey started"
      debug:
        msg: "Rekey initiated with nonce: {{ rekey_nonce }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Submit unseal keys for rekey"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault operator rekey \
          -nonce={{ rekey_nonce }} \
          -format=json \
          {{ key }}
      loop: "{{ current_unseal_keys[:vault_key_threshold | int] }}"
      loop_control:
        index_var: idx
        loop_var: key
        label: "Key {{ idx + 1 }}"
      register: rekey_results
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Parse new unseal keys"
      set_fact:
        new_unseal_keys: "{{ (rekey_results.results[-1].stdout | from_json).keys_base64 }}"
      when: rekey_results.results[-1].stdout is defined
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Fail if no new keys"
      fail:
        msg: "Rekey failed - no new keys generated"
      when: new_unseal_keys is not defined
      run_once: true

    - name: "[rekey] Show new keys generated"
      debug:
        msg:
          - "=============================================="
          - "NEW UNSEAL KEYS GENERATED"
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Show new unseal keys"
      debug:
        msg: "New Unseal Key {{ idx + 1 }}: {{ key }}"
      loop: "{{ new_unseal_keys }}"
      loop_control:
        index_var: idx
        loop_var: key
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Show footer"
      debug:
        msg:
          - "=============================================="
          - "Old keys are now INVALID"
          - "Saving to temp file for fault tolerance"
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 7: SAVE TO TEMP FILE FIRST (fault tolerance)
    # =========================================================================

    - name: "[rekey] Build credentials JSON"
      set_fact:
        vault_rotate_creds_json:
          root_token: "{{ current_root_token }}"
          unseal_keys: "{{ new_unseal_keys }}"
          key_threshold: "{{ vault_key_threshold }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Save credentials to rotate temp file"
      copy:
        content: "{{ vault_rotate_creds_json | to_nice_json }}"
        dest: "{{ vault_creds_rotate_tmp_path }}"
        mode: "0600"
        owner: root
        group: root
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Show temp file saved"
      debug:
        msg: "New credentials saved to temp file: {{ vault_creds_rotate_tmp_path }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 8: DISTRIBUTE NEW CREDENTIALS TO ALL MANAGERS
    # =========================================================================

    - name: "[vault-creds] Broadcast new credentials to all managers"
      set_fact:
        _dist_current_root_token: "{{ hostvars[master_manager_fact].current_root_token }}"
        _dist_new_unseal_keys: "{{ hostvars[master_manager_fact].new_unseal_keys }}"

    - name: "[vault-creds] Distribute new credentials to all managers"
      include_tasks: tasks/tasks-vault-distribute-creds.yaml
      vars:
        vault_root_token_tmp: "{{ _dist_current_root_token }}"
        vault_unseal_keys_tmp: "{{ _dist_new_unseal_keys }}"
        vault_creds_host_path_tmp: "{{ vault_creds_host_path }}"

    # =========================================================================
    # STEP 9: DELETE TEMP FILE (after successful distribution)
    # =========================================================================

    - name: "[rekey] Delete rotate temp file after successful distribution"
      file:
        path: "{{ vault_creds_rotate_tmp_path }}"
        state: absent
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[rekey] Show temp file deleted"
      debug:
        msg: "Temp file deleted: {{ vault_creds_rotate_tmp_path }}"
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    # =========================================================================
    # STEP 10: VERIFY
    # =========================================================================

    - name: "[verify] Check Vault status after rekey"
      shell: |
        kubectl exec -n {{ vault_namespace }} vault-0 -- vault status -format=json
      register: vault_final_status
      changed_when: false
      delegate_to: "{{ master_manager_fact }}"
      run_once: true

    - name: "[verify] Show final status"
      debug:
        msg:
          - "=============================================="
          - "VAULT REKEY COMPLETED"
          - "=============================================="
          - "Vault sealed: {{ (vault_final_status.stdout | from_json).sealed }}"
          - "New credentials distributed to: {{ groups['managers'] | join(', ') }}"
          - "Credentials file: {{ vault_creds_host_path }}"
          - "=============================================="
      delegate_to: "{{ master_manager_fact }}"
      run_once: true
